d[[toString(k)]] <- rules_count
# Load required packages
library(dplyr)
library(arules)
library(arulesViz)
library(ggplot2)
# Load the data files
orders <- read.csv("order_products__prior.csv", nrows = 30000) # to reduce computability, we just load the first 30000 rows.
# randomly sample the rows
products <- read.csv("products.csv")
# Check the data structure
glimpse(orders)
glimpse(products)
# Inspect first few rows
head(orders)
head(products)
# Join the data on product_id
df <- orders %>%
inner_join(products, by = "product_id") %>%
group_by(order_id) %>%
summarise(basket = as.vector(list(product_name)))
# check the cleaned data
head(df)
# convert dataframe to sparse matrix for further analysis
df_tr <- as(df$basket, "transactions")
# check how many transactions and items
df_tr
# inspect first few transactions
inspect(head(df_tr))
# Display the distribution of number of items per basket
hist(size(df_tr), breaks = 0:80, xaxt = "n",
main = "Number of Items per Basket", xlab = "Number of Items", col = "#00ADB5")
axis(side = 1, at = seq(0, 80, by = 10), cex.axis = 0.8) # set x-axis label
mtext(paste("Total Baskets: ", length(df_tr)), line = -1) # set sub-title
itemFrequencyPlot(df_tr, topN = 15, type = "absolute", col = "#00ADB5",
main = "Top 15 Most Frequent Items - Absolute")
itemFrequencyPlot(df_tr, topN = 15, type = "relative", col = "#00ADB5",
main = "Top 15 Most Frequent Items - Relative")
# use apriori function to get most frequent itemsets
ft_rules <- apriori(df_tr, parameter = list(target = "frequent itemsets", supp = 0.002, minlen = 2))
# inspect the rules by support from high to low
inspect(sort(ft_rules, by = "support", decreasing = T)[1:10]) # top 10 itemsets
# Plot the top 10 itemsets
plot(sort(ft_rules, by = "support", decreasing = T)[1:10], method = "graph", control = list(cex=0.6), main = "Top 10 Most Frequent Bought-Together Itemsets")
# Load packages
library(tidyverse)
# 2. Load data file
df <- read_csv("district_data.csv")
# check first a few rows
head(df)
# check the dimension of data
dim(df)
# check the summary of data
summary(df)
# check column names
names(df)
# rename the column names
names(df) <- c("district", "avg_income", "median_age")
names(df)
# remove $ and thousand separator
df$avg_income <- gsub("[$,]", "", df$avg_income)
# convert to numeric
df$avg_income <- as.numeric(df$avg_income)
# check the column types
glimpse(df)
qplot(x = df$median_age, y = df$avg_income, label = df$district, geom = "text")
df_scaled <- as.data.frame(scale(df[c("median_age", "avg_income")]))
head(df_scaled)
# define the number of clusters
k_clusters <- 3
# get clustering result
k_means_result <- kmeans(df_scaled, centers = k_clusters)
# add cluster result to original data
df$cluster <- as.factor(k_means_result$cluster)
head(df)
# visualize cluster result
qplot(x = df$median_age, y = df$avg_income, label = df$district, geom = "text", color = df$cluster)
# set maximum number of cluster
k_cluster_max <- 10
# iterate through the number of clusters from 1 to 10
within_sum_of_squares <- sapply(1:k_cluster_max,
function(k){
kmeans(df_scaled, centers = k)$tot.withinss})
# visualize the output
plot(1:k_cluster_max, within_sum_of_squares, type = "b",
xlab = "Number of clusters", ylab = "Total within cluster sum of squares")
# conduct clustering with 4 clusters
k_means_result_2 <- kmeans(df_scaled, centers = 4)
# add result to dataframe
df$cluster <- as.factor(k_means_result_2$cluster)
# visualize cluster result with ggrepel to avoid label overlapping
library(ggrepel)
qplot(x = df$median_age, y = df$avg_income, label = df$district, color = df$cluster,
xlab = "Median Age", ylab = "Average Income") + geom_text_repel()
# add result to dataframe
df$cluster <- as.factor(k_means_result_2$cluster)
# conduct clustering with 4 clusters
k_means_result_2 <- kmeans(df_scaled, centers = 4)
# add result to dataframe
df$cluster <- as.factor(k_means_result_2$cluster)
# visualize cluster result with ggrepel to avoid label overlapping
library(ggrepel)
qplot(x = df$median_age, y = df$avg_income, label = df$district, color = df$cluster,
xlab = "Median Age", ylab = "Average Income") + geom_text_repel()
# conduct clustering with 4 clusters
k_means_result_2 <- kmeans(df_scaled, centers = 4)
# add result to dataframe
df$cluster <- as.factor(k_means_result_2$cluster)
# visualize cluster result with ggrepel to avoid label overlapping
library(ggrepel)
qplot(x = df$median_age, y = df$avg_income, label = df$district, color = df$cluster,
xlab = "Median Age", ylab = "Average Income") + geom_text_repel()
install.packages(c("arules", "clipr", "curl", "DT", "foreach", "foreign", "ggplot2", "hms", "httr", "iterators", "knitr", "markdown", "modelr", "nlme", "Rcpp", "rmarkdown", "rpart.plot", "seriation", "sys", "visNetwork", "whisker", "xfun", "xml2"))
install.packages(c("arules", "clipr", "curl", "DT", "foreach", "foreign", "ggplot2", "hms", "httr", "iterators", "knitr", "markdown", "modelr", "nlme", "Rcpp", "rmarkdown", "rpart.plot", "seriation", "sys", "visNetwork", "whisker", "xfun", "xml2"))
install.packages(c("arules", "ggplot2", "markdown"))
install.packages(c("DT", "httr"))
install.packages(c("clipr", "curl"))
install.packages(c("foreach", "foreign", "hms", "iterators", "knitr", "modelr", "nlme", "Rcpp", "rmarkdown", "rpart.plot", "seriation", "sys", "visNetwork", "whisker", "xfun", "xml2"))
# Load packages
library(ggplot2)
library(tidyverse)
library(corrplot)
install.packages("corrplot")
# Load packages
library(ggplot2)
library(tidyverse)
library(corrplot)
library(plotly)
library(caTools)
# Load packages
library(ggplot2)
library(tidyverse)
library(corrplot)
library(plotly)
library(caTools)
setwd("~/data_analysis/data_analytic_projects/predictive_analytics/regression/predict_diamond_price")
# Load the data
diamonds <- read.csv("diamonds.csv")
# inspect first few rows
head(diamonds)
# check data summary
summary(diamonds)
# Load the data
diamonds <- read.csv("diamonds.csv")
# check data dimension
dim(diamonds)
# inspect first few rows
head(diamonds)
# Load the data
diamonds <- read.csv("diamonds.csv")
# check data dimension
dim(diamonds)
# inspect first few rows
head(diamonds)
# check data summary
glimpse(diamonds)
# have a glimpse on data
glimpse(diamonds)
# check data summary
summary(diamonds)
# create color ordinary data
# check the levels of color variable
levels(diamonds$color)
# create color ordinary data
# check the levels of color variable
factor(diamonds$color)
# create color ordinary data
# check the levels of color variable
levels(diamonds$color)
# create color ordinary data
# check the levels of color variable
levels(diamonds$color) <- reverse.levels(levels(diamonds$color))
# create color ordinary data
# check the levels of color variable
diamonds$color_ord <- diamonds$color
# create color ordinary data
# check the levels of color variable
diamonds$color_ord <- diamonds$color
diamonds$color_ord <- as.integer(diamonds$color_ord)
head(diamonds)
# create color ordinary data
# check the levels of color variable
diamonds$color_ord <- diamonds$color
factor(diamonds$color_ord) <- fct_rev(factor(diamonds$color_ord))
# create color ordinary data
# check the levels of color variable
diamonds$color_ord <- diamonds$color
diamonds$color_ord <- fct_rev(factor(diamonds$color_ord))
diamonds$color_ord <- as.integer(diamonds$color_ord)
head(diamonds)
# select numeric variables
diamonds <- select(diamonds, carat, cut_ord, color_ord, clarity_ord, price)
head(diamonds)
# split data into train and test sets
set.seed(227)
sample <- sample.int(n = nrows(diamonds), size = floor(0.8*nrows(diamonds)), replace = F)
# split data into train and test sets
set.seed(227)
sample <- sample.int(n = nrow(diamonds), size = floor(0.8*nrow(diamonds)), replace = F)
train <- diamonds[sample,]
test <- diamonds[-sample,]
cor(diamonds, diamonds$price)
cor(diamonds$price, diamonds$carat)
cor(diamonds, diamonds$price)
linearMod <- lm(price ~., data=diamonds)
print(linearMod)
summary(linearMod)
AIC(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=test)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred)
cor(diamonds)
diamond_cor <- cor(diamonds)
corrplot(diamond_cor, method = "circle")
corrplot(diamond_cor)
corrplot(diamond_cor, method = "pie")
corrplot(diamond_cor, method = "pie", type = "lower")
corrplot(diamond_cor, method = "pie", type = "upper")
corrplot(diamond_cor, method = "pie", type = "left")
corrplot(diamond_cor, method = "pie", type = "upper")
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + geom_smooth("lm")
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + geom_smooth("lm")
# Load packages
library(ggplot2)
library(tidyverse)
library(corrplot)
library(plotly)
library(caTools)
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + geom_smooth("lm")
ggplot(diamonds, mapping = aes(x=carat, y=price)) + geom_point() + geom_smooth("lm")
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + geom_smooth("lm")
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() #+ geom_smooth("lm")
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + geom_smooth(method = "lm")
ggplot(diamonds, aes(x=cut_ord, y=price)) + geom_point() + geom_smooth(method = "lm")
linearMod <- lm(price ~ carat + factor(cut_ord) + factor(color_ord) + factor(clarity_ord), data=diamonds)
print(linearMod)
summary(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=test)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred)
# select numeric variables
diamonds <- select(diamonds, carat, cut, color, clarity, price)
# Load the data
diamonds <- read.csv("diamonds.csv")
# check data dimension
dim(diamonds)
# inspect first few rows
head(diamonds)
# remove first column
diamonds <- diamonds[-1]
# select numeric variables
diamonds <- select(diamonds, carat, cut, color, clarity, price)
# inspect first few rows after data cleaning
head(diamonds)
# split data into train and test sets
set.seed(227)
sample <- sample.int(n = nrow(diamonds), size = floor(0.8*nrow(diamonds)), replace = F)
train <- diamonds[sample,]
test <- diamonds[-sample,]
diamond_cor <- cor(diamonds)
corrplot(diamond_cor, method = "pie", type = "upper")
# inspect first few rows after data cleaning
head(diamonds)
diamond_cor <- cor(diamonds)
corrplot(diamond_cor, method = "pie", type = "upper")
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + geom_smooth(method = "lm")
linearMod <- lm(price ~ carat + factor(cut_ord) + factor(color_ord) + factor(clarity_ord), data=diamonds)
linearMod <- lm(price ~ ., data=diamonds)
print(linearMod)
summary(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=test)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred)
head(actual_pred, 20)
# split data into train and test sets
set.seed(227)
sample <- sample.int(n = nrow(diamonds), size = floor(0.9*nrow(diamonds)), replace = F)
train <- diamonds[sample,]
test <- diamonds[-sample,]
linearMod <- lm(price ~ ., data=diamonds)
print(linearMod)
summary(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=test)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred, 20)
linearMod <- lm(price ~ carat + cut + color, data=diamonds)
print(linearMod)
summary(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=test)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred, 20)
linearMod <- lm(price ~ carat, data=diamonds)
print(linearMod)
summary(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=test)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred, 20)
linearMod <- lm(price ~ poly(carat, 2, raw = TRUE), data=diamonds)
print(linearMod)
summary(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=test)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred, 20)
linearMod <- lm(price ~ poly(carat, 2, raw = TRUE) + color + cut + clarity, data=diamonds)
print(linearMod)
summary(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=test)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred, 20)
data("marketing", package = "datarium")
install.packages("datarium")
data("marketing", package = "datarium")
head(marketing, 4)
data("marketing", package = "datarium")
head(marketing, 4)
dim(marketing)
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + stat_smooth()
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + stat_smooth(method = "lm")
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + stat_smooth(method = "glm")
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + stat_smooth(method = "lm", formula = y ~ poly(x, 2))
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + stat_smooth()
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1)
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + stat_smooth()
cor(marketing)
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + geom_smooth()
linearMod <- lm(price ~ ., data=diamonds)
print(linearMod)
summary(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=test)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred, 20)
summary(actual_pred)
# Load packages
library(ggplot2)
library(tidyverse)
library(corrplot)
library(plotly)
library(caTools)
library(caret)
# Load packages
library(ggplot2)
library(tidyverse)
library(corrplot)
library(plotly)
library(caTools)
library(caret)
linearMod <- train(price ~ ., data = diamonds, method = 'lm',
trControl = trainControl(
method = 'cv',
number = 10,
verboseIter = TRUE
))
print(linearMod)
summary(linearMod)
# check data summary
summary(diamonds)
summary(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=test)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred, 20)
summary(actual_pred)
# Load the data
diamonds <- read.csv("diamonds.csv")
new_diamonds <- read.csv("new-diamonds.csv")
# check data dimension
dim(diamonds)
dim(new_diamonds)
summary(new_diamonds)
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + geom_smooth()
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + geom_smooth(method = "lm")
# check data summary
summary(diamonds)
# have a glimpse on data
glimpse(diamonds)
linearMod <- train(price ~ ., data = diamonds, method = 'lm',
trControl = trainControl(
method = 'cv',
number = 5,
verboseIter = TRUE
))
print(linearMod)
summary(linearMod)
# remove first column
diamonds <- diamonds[-1]
# inspect first few rows after data cleaning
head(diamonds)
linearMod <- train(price ~ ., data = diamonds, method = 'lm',
trControl = trainControl(
method = 'cv',
number = 5,
verboseIter = TRUE
))
print(linearMod)
summary(linearMod)
linearMod <- train(price ~ ., data = diamonds, method = 'lm',
trControl = trainControl(
method = 'cv',
number = 10,
verboseIter = TRUE
))
print(linearMod)
summary(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=test)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred, 20)
summary(actual_pred)
# use the model to predict for test data
pricePred <- predict(linearMod, data=new_diamonds)
sum(pricePred)
linearMod <- train(price ~ ., data = train, method = 'lm',
trControl = trainControl(
method = 'cv',
number = 10,
verboseIter = TRUE
))
print(linearMod)
summary(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=test)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred, 20)
summary(actual_pred)
linearMod <- train(price ~ ., data = diamonds, method = 'lm',
trControl = trainControl(
method = 'cv',
number = 10,
verboseIter = TRUE
))
print(linearMod)
summary(linearMod)
# use the model to predict for test data
new_diamonds$price <- predict(linearMod, data=new_diamonds)
# use the model to predict for test data
pricePred <- predict(linearMod, data=diamonds)
mean(pricePred)
summary(actual_pred)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=test$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred, 20)
summary(actual_pred)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=diamonds$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred, 20)
summary(actual_pred)
new_diamonds$price <- predict(linearMod, data=new_diamonds[-1])
linearMod <- train(price ~ ., data = diamonds, method = 'lm',
trControl = trainControl(
method = 'cv',
number = 10,
verboseIter = TRUE
))
print(linearMod)
summary(linearMod)
# use the model to predict for test data
pricePred <- predict(linearMod, data=diamonds)
mean(pricePred)
# combine actual and predict data
actual_pred <- data.frame(cbind(actuals=diamonds$price, preds=pricePred))
# check correlation of actual and predicted data
cor(actual_pred)
head(actual_pred, 20)
